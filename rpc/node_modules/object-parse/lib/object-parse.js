/*
Object-parse is a Javascript helper program to aid in data managment and functional programming design.

 Copyright (C) 2015  Robert Edward Steckroth II <RobertSteckroth@gmail.com>

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

Program author: Robert Edward Steckroth II <RobertSteckroth@gmail.com>
*/

// Auther: Robert Edward Steckroth II <RobertSteckroth@gmail.com>

var Wizkit = require("wizkit"), // Wizkit will give us cross-platform variable print-out and logging.
up = new Wizkit()

var ObjectParse = function() {
  // Description:
  // This script provides a portable and easy to manage options/settings mechanism.
  // The settings and options are self contained and thusly can be scoped separately for integrity.

  this.getterFuncString = (this.__lookupGetter__ && "__lookupGetter__") || (this.lookupGetter && "lookupGetter") || ("") // For Ie browser
  this.optionsGetSet = this.functional_tools()  // Used to avoid circular callbacks associated with getters and setters
  this.settingsGetSet = this.functional_tools() // Used to avoid circular callbacks associated with getters and setters
  this.print_options = ""
  this.print_settings = ""

}

ObjectParse.prototype = {

  get is_object_parse() {

    return this instanceof ObjectParse
  },

  functional_tools: function() {

    return new this.ScopedGetSet()
  },

  ScopedGetSet: function() {
    // This will serve as a getter/setter bypass.
    // This class provides a third party Object (this.obj) which can be set or retrieved without activating the getter or setter associated with the class
    this.obj = {}
    this.old_obj = {}


  },

  parse_cli: function() {
    // Strictly Nodejs. Turns the command line parameters into the syntax corresponding ECMA Objects
    // All Objects need to be wrapped with the converse quotation used in the Object notation. E.g. "my_obj={'myvar': true}', my_obj='{"myvar": "value"}'
    // This function requires that the cli parameters sit next to the bisector (=) character. E.g. myArg=4, my_obj=' {"myvar": true}'
    if ( typeof process === "undefined" || !process.argv ) return {}

    var args = [], cli_obj = {}, p_len = process.argv.length
    for ( var x = 0; x < p_len; x++ ) {
      args = process.argv[x].split("=") // Object qualifier is the left of the = and the value is the right of it
      if ( args.length === 2 )
        try {
          var new_str = args[1]
          if ( new_str.match(/^\ *\{.*\}\ *$/) && new_str.match(/..*[\"\']\ *\:..*/) ) // Check to see if the string conforms to ECMA Object format/syntax.
            new_str = new_str.replace(/\' *([\:\,\}])/g, "\"\$1").replace(/([\:\,\{]) *\'/g, "\$1\"") // Replace all ' with " where nessesary
          cli_obj[args[0]] = JSON.parse(new_str) // See if the String can be transformed into a Object
        } catch(error) {
          cli_obj[args[0]] = args[1] // The value should stay a String sense it can not be parsed into a Object
        }
    }

    return cli_obj
  },

  options: function() {
    // options can be set using the intrinsic function based method or the properties can be set directly to this member
    // Note: multiple objects can be passed into this from the function
    var This = this

    for ( var i in arguments ) // check all arguments and loop through them as Objects
      for ( var y in arguments[i] )
        if ( arguments[i][y].constructor === Array ) { // Options only accepts Arrays
          if ( ! this.options[this.getterFuncString](y) ) {
            this.options.__defineGetter__(y, this.optionsGetSet.scoped_getter(y, arguments[i][y]) )
            this.options.__defineSetter__(y, this.optionsGetSet.scoped_setter(y, function(qualifier, value) {
                // All of the individual options are re-set using a setter.
                if ( value.constructor === Array ) {
                  this.obj[qualifier] = value
                  if ( This.options[y].length <= 1 ) // Undo the settings value when a new default needs to be used
                    This.settingsGetSet.base[y] = undefined // Undo the corillating settings value so that configure will re-assign the default if necessary
                  This.configure() // call configure whenever an option is re-set.
                }
                else {
                  up.sp("Options need to be set with an array as its value. Object passed in was a").sp(typeof value).line(value).log()
                }
              })
            )
            this.configure() // Configure after setting the setter
          }
          else {

            if ( this.options[y].length <= 1 ) // Undo the settings value when a new default needs to be used
              this.settingsGetSet.base[y] = undefined // Undo the corillating settings value so that configure will re-assign the default if necessary
            this.options[y] = arguments[i][y] // setter will be called here and thusly the configure()
          }
        }
        else { // Options can only be set with an Array object
          up.sp("Options need to be set with an array as its value. Object passed in was a").sp(typeof arguments[i][y]).line(arguments[i][y]).log()
        }

    return this.options
  },

  settings: function() {
    // This member holds all of the settings as properties. It also returns a function to help set itself.
    // The properties are set with a getter function in combination with ScopedGetSet() prototype.
    // settings can be set using the intrinsic function based method or the properties can be set directly
    // Note: multiple objects can be passed into this from the function

    if ( arguments.length )
      for ( var i in arguments )
        this.configure(arguments[i]) // Configure will create a getter for this.settings with any valid arguments (see options)
    else
      this.configure()


    return this.settings // This will always contain the current settings as properties using getter retrieval
  },

  configure: function(requested) {
    // Note: this member is idempotent.
    // Parameters are passed in as a single Object and used to change the settings with any updates which can be made.
    // The requested parameter is compared against the options variable in determining which this.settings can be set or which needs to use the default listed in the this.options
    // If no settings Object is passed in, the default values from options will be set to any non-set this.settings
    var has_option = false
    var This = this

    var setter_func = function(qualifier, value) {
      // This is used twice below in this member (configure)
      // Tt will set the setting without creating a circular callback and also ensure that the value conforms to the stated options
      this.base[qualifier] = value
      var single_obj = {}
      single_obj[qualifier] = value
      // We need to check any values set to the settings against the options to ensure validity
      This.configure(single_obj) // The single_obj is used for efficiency reasons.
    }

    for ( var s in requested ) {
//          if ( ! this.options[s] ) {
//          console.log("Warning: option ["+s+"] does not exist in options. Available options are: "+Object.keys(this.options))
//      }
      // All of the passed in requested settings are first assigned and then reverted back to the options defualt if nessesary
      if ( ! this.settings[this.getterFuncString](s) ) {
        // Add the setter to any objects passed in which do not have a setter yet.
        this.settings.__defineGetter__(s, this.settingsGetSet.scoped_getter(s, requested[s]) ) // This will set the base obj to the value as well
        this.settings.__defineSetter__(s, this.settingsGetSet.scoped_setter(s, setter_func) )
      } else {
        this.settingsGetSet.base[s] = requested[s]
      }
    }
    // The currently set options and settings are set here for easy and efficient printing
    this.print_settings = "--- settings:\n"
    this.print_options = "--- options:\n"

    for ( var o in this.options ) {

      // Loop through all of the options and ensure that the corresponding settings variable is valid
      // Note: there is 0% of anyone ever understanding what is happing below this line (don't try).
      this.print_options += up.color(false).add("{").add(o).add(":").sp(this.options[o]).add("}").add_line().toString()
      // This is an efficient way of stored the set values for this.options

      // define all of the setters and getters for the this.settings member here as well using the options qualifiers
      if ( ! this.settings[this.getterFuncString](o) ) {
        this.settings.__defineGetter__(o, this.settingsGetSet.scoped_getter(o) ) // Scoped getter base obj will be set to undefined if no second parameter was passed to it
        this.settings.__defineSetter__(o, this.settingsGetSet.scoped_setter(o, setter_func) )
      }

      has_option = false
      if ( this.options[o].length <= 1 && typeof this.settings[o] === "undefined" ) {
      // Set the this.options default if the corresponding this.options only contains one entry and this.settings is undefined (not yet set)
        this.settingsGetSet.base[o] = this.functional_tools().scoped_getter(0, this.options[o][0])(requested && requested[o] || undefined)
      }
      else {
        // Set the requested object to the this.settings member if this.options contains a value for it in the corresponding qualifier
        for ( var i = 0; i < this.options[o].length; i++ ) {
          var set_obj = this.functional_tools().scoped_getter(i, this.options[o][i])(requested && requested[o] || undefined)
          if ( this.settings[o] === set_obj || typeof this.settings[o] === "undefined" ) {
            this.settingsGetSet.base[o] = set_obj
            has_option = true
            break
          }
        }
      }

      // Unable to find a match between this.settings and any requested objects and the corrisponding this.options values
      if ( !has_option && this.options[o].length > 1 ) {
        // Re-set any this.settings with the defualt this.options value if it was unable to be set
          var setting_with_type = up.sp(typeof this.settings[o]).add("(").add(this.settings[o]).add(")").toString(), options_with_type = up.add(), opt

          var warn = up.sp("Warning: option [").sp(o).sp("] does not contain a value:").sp(setting_with_type) // Create our warning and output it
          .line("\tAvailable options are:").sp() //  options_with_type.substr(0, options_with_type.length-7)).log()

          for ( var v in this.options[o] ) {
            opt = this.functional_tools().scoped_getter(v, this.options[o][v])(requested && requested[o] || undefined)
            warn.add(typeof opt).add("(").add(this.options[o][v]).add(")").add(Object.keys(this.options[o]).pop() === v && "." || ", ")
          }

          warn.log()
          this.settingsGetSet.base[o] = this.functional_tools().scoped_getter(0, this.options[o][0])(requested && requested[o] || undefined)
      }
      this.print_settings += up.color(false).add("{").sp(o).sp(":").sp(this.settings[o]).sp("}").add_line().toString() // Add the current settings to the string for printing
      // This is an efficient way of stored the set values for this.settings
    }
    return this
  }
}

ObjectParse.prototype.ScopedGetSet.prototype = {

  get base() {
    return this.obj
  },
  scoped_getter: function(qualifier, value) {
    // Returns a function which can be used by a getter
    // The value is linked to this.obj and returned without activating the getter again thus avoiding a circular callback
    this.obj[qualifier] = value
    // If the value is a function, then the function is called. This is out of convenience and is not utilized by the script
    this.old_obj[qualifier] = null
    var This = this, is_func = new Object().toString.call(this.obj[qualifier]) === "[object Function]"

    return function(value) { // Return the stored base object or call the function id it was set to one
      // value can be passed in via a lone call, e.g. new ScopedGetSet().scoped_getter()(value)
      This.old_obj[qualifier] = is_func && This.obj[qualifier](value, This.old_obj[qualifier]) || This.old_obj[qualifier]
      return is_func && This.old_obj[qualifier] || This.obj[qualifier]
    }

  },

  scoped_setter: function(qualifier, callback) {
    // Returns a function which can be used by a setter
    // The callback is called whenever the object linked though the scoped_getter is set
    var This = this, is_func = new Object().toString.call(callback) === "[object Function]"
    return function(value) {
      // This callback should be used to set the this.obj object with the value being set
      is_func && callback.call(This, callback.length>0&&qualifier||undefined, callback.length>1&&value||undefined)
    }
  },

}

if ( typeof module === "object" ) // This avoids browser errors
  module.exports = ObjectParse
