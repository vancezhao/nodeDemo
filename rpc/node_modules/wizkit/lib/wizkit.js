/*
Wizkit is a helpfull program to be used with JavaScript and some terminal output commands in response to the lack of printing options.

 Copyright (C) 2015  Robert Edward Steckroth II <RobertSteckroth@gmail.com>

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

Program author: Robert Edward Steckroth II <RobertSteckroth@gmail.com>
*/

// TODO: add overide_message field
// TODO: add this to output for browsers https://github.com/icodeforlove/Console.js
// TODO: callbacks need property getting recondition for error_cb paramters

var fake_colors = function() { // compound will be place at the start of each new line/object in the output
  var rs = function(s) { return s || ""}
  return { white: rs, grey: rs, cyan: rs, magenta: rs, red: rs, blue: rs, black: rs, yellow: rs, green: rs }
}

var clrs = (typeof module !== "undefined" && typeof module.exports !== "undefined") && require("colors/safe") || fake_colors()

var Wizkit = function() {

  var logger_name = null, args = null
  for ( var x = 0; x < arguments.length; x++ ) {
    if ( typeof logger_name !== "string" && typeof arguments[x] === "string" ) {
      logger_name = arguments[x]
      continue
    }
    if ( !args && arguments[x] && arguments[x].is_object_parse ) {
      args = arguments[x]
      continue
    }
  }

  logger_name = logger_name||""

  if ( !args || !args.is_object_parse ) {
    args = {settings: function(){}, options: function(){}} // create a mock object-parse library (see https://www.npmjs.com/package/object-parse)
    args.settings.debug = "verbose"
  }
  this.args = args
  this.log_app_string = logger_name
  this.indentation_string = "  "

}

Wizkit.prototype = {

  get is_wizkit() {
    return this instanceof Wizkit
  },
  get contains_data() { // If there is any output availible including newlines, spaces and/or tabs or characters
    return false
  },
  set log_title(val) {
    this.log_app_string = val
  },
  get log_title() {
    return this.log_app_string
  },
  escape: function(obj, def) { // a generic escaping function
    // If the obj is not a string or returns empty, then return the default value or the original object if no default value was provided.
    if ( typeof obj === "string" && obj.length > 0 )
      return obj.replace(/[\ \'\"\!\@\#\$\%\^\&\*\(\)\+\;\:\?\>\<\[\]\{\}\`\~\/\\]/g, '_').replace(/_+/g, '_') //"' quoate is for Bitbucket parsing fix with web page source display
    else if ( arguments.length > 1 )
      return def
    else
      return obj
  },
  new_copy: function() {

    var logger_name = null, args = null
    for ( var x = 0; x < arguments.length; x++ ) {
      if ( typeof logger_name !== "string" && typeof arguments[x] === "string" ) {
        logger_name = arguments[x]
        continue
      }
      if ( !args && arguments[x] && arguments[x].is_object_parse ) {
        args = arguments[x]
        continue
      }
    }
    return new Wizkit(args||this.args, logger_name)

  },
  FakeLogger: function() { // The FakeLogger is used to disable logging when debug is set to false (it is efficiant this way).

    var This = this
    var f = function() {
      return This
    }
    for ( var o in Wizkit.prototype.Logger.prototype )
      if ( o.substr(0,4) !== "log_" ) // Things like "log_true" and "log_false" should never be fake
        this.__defineGetter__(o, function() { return f })

    this.__defineGetter__("log_false", function() { return function() { return false } })
    this.__defineGetter__("log_true", function() { return function() { return true } })

    this["toString"] = function() { } // prevent reduntant parsing when an always logger is passed into a logger with debuging set to true or false

  },
  Logger: function(settings, app_name) { // The Logger constructer is sub-classed here in Wizkit

    this.settings = settings || {}
    if ( typeof this.settings.use_color !== "undefined" )
      this.use_color = this.settings.use_color
    else
      this.use_color = true

    if ( typeof this.settings.use_color !== "undefined" )
      this.max_line_characters = this.settings.max_line_characters
    else
      this.max_line_characters = 300

    this.last_command = null
    this.output = ""
    this.log_title = app_name && app_name.toString() || ""
    this._cache = []
    this.ignore_separater = false
    this._contains_data = false

    this.compress_output = true


  },
  get PROGRAM_POINT() {
    return new Error().stack.split("\n")[3].replace(/ */, "")
  },
  get data() {
    return this.args
  },
  get _args() {
    return this.args
  },
  protect_callbacks: function() {

    for ( var o in arguments ) {
      if ( typeof arguments[o] === "function" )
      arguments[o].__defineGetter__("never_switch_proto_flag", function() { return true })
      for ( var i in arguments[o] )
        if ( typeof arguments[o][i] === "function" ) // These will not allow the prototype to be switch with wizkit callback generators
          arguments[o][i].__defineGetter__("never_switch_proto_flag", function() { return true })
    }
  },
  /*
  unset_callbacks_protection: function() {
    for ( var o in arguments ) {
      if ( typeof arguments[o] === "function" && arguments[o]["never_switch_proto_flag"] )
        delete arguments[o]["never_switch_proto_flag"] // Remove the getter from the object
      for ( var i in arguments[o] )
        if ( typeof arguments[o][i] === "function" && arguments[o][i]["never_switch_proto_flag"] )
          delete arguments[o][i]["never_switch_proto_flag"] // Remove the getter from the function
    }

  },
  */
  get always() {
    var This = this
    return function() {
      return new This.Logger(This.args.settings, This.log_title)._log_option({"ignore_separater": true})
    }
  },
  get pass() {
    return This.args.settings.debug === "verbose" && new This.Logger(This.args.settings, This.log_title)._log_option({"ignore_separater": true}) || new This.FakeLogger()
  },
  get color() {
    var This = this
    return function(bool) {
      return This.args.settings.debug === "verbose" && new This.Logger(This.args.settings, This.log_title)._log_option({"ignore_separater": true, "use_color": !!(bool)}) || new This.FakeLogger()
    }
  },
  get clear() { // Does nothing at the root level of the logger object
    var This = this
    return function() {
      return This.pass()
    }
  },
  get log() { // Provides constructer based namespace for the Logger to be used with Wizkit
    var This = this
    return function() {
      return This.args.settings.debug === "verbose" && new This.Logger(This.args.settings, This.log_title).log.apply(This, arguments) || new This.FakeLogger()
    }
  },
  get line() {
    var This = this
    return function() {
      return This.args.settings.debug === "verbose" && new This.Logger(This.args.settings, This.log_title).line.apply(This, arguments) || new This.FakeLogger()
    }
  },
  get add_line() {
    var This = this
    return function() {
      return This.args.settings.debug === "verbose" && new This.Logger(This.args.settings, This.log_title).add_line.apply(This, arguments) || new This.FakeLogger()
    }
  },
  get add() {
    var This = this
    return function() {
      return This.args.settings.debug === "verbose" && new This.Logger(This.args.settings, This.log_title).add.apply(This, arguments) || new This.FakeLogger()
    }
  },
  get sp() {
    var This = this
    return function() {
      return This.args.settings.debug === "verbose" && new This.Logger(This.args.settings, This.log_title)._log_option({"ignore_separater": true}).sp.apply(This, arguments) || new This.FakeLogger()
    }
  },
  get tab() {
    var This = this
    return function() {
      return This.args.settings.debug === "verbose" && new This.Logger(This.args.settings, This.log_title)._log_option({"ignore_separater": true}).tab.apply(This, arguments) || new This.FakeLogger()
    }
  },
  get space() {
    var This = this
    return function() {
      return This.args.settings.debug === "verbose" && new This.Logger(This.args.settings, This.log_title)._log_option({"ignore_separater": true}).space.apply(This, arguments) || new This.FakeLogger()
    }
  },

  success_cb: function(f, proto_accept, message) {

    var tmp_proto_accept, tmp_f, tmp_message
    // This will swap the paramters passed in to the correct order so there is no need to remmeber it
    for ( var x in arguments )
      if ( typeof arguments[x] === "function" ) {
        tmp_f = arguments[x]
        for ( var n in arguments )
          if ( n === x )
            continue
          else if ( typeof arguments[n] === "string" || (arguments[n] && arguments[n].is_wizkit && arguments[n].contains_data ) )
            tmp_message = arguments[n]
          else if ( typeof arguments[n] === "object" )
            tmp_proto_accept = arguments[n]
        break
      }
    f = tmp_f
    proto_accept = tmp_proto_accept
    message = tmp_message

    if ( f && f.is_set ) {
      f.message = message || f.message
      return f
    }

    var rf = function() {

      if ( typeof f === "function" ) {
        f.pro = f.pro || {} // Better safe than sorry with multi-level object comparisons
        f.pro.message = rf.message && rf.message.toString() || ""
        f.apply(f.pro, arguments)
      }
    }

    rf.len = 0 // We make sure that the number or paramters this function accepts is the same as the passed in function
    if ( typeof f === "function" ) {
      rf.len = f.length // We make sure that the number or paramters this function accepts is the same as the passed in function
      if ( !f["never_switch_proto_flag"] ) { // Do not allow for prototype switching if this flag is set
        f.pro = (typeof proto_accept === "object" && proto_accept) || f.prototype
      }
      else if ( typeof proto_accept === "object" ) {
        f.pro = f.prototype
        var output = this.args.settings.debug !== false && this.always() || this.pass()
        output.line(clrs.red("<: Error "+output.PROGRAM_POINT)).line().tab(clrs.blue("Warning message:"))
        .sp("an attempt to switch the callback of a function with the [never_switch_proto_flag] property set was made.")
        .sp("This is not harmfull but may be unintended by the programer.").log()
      }
    }
      //    rf.__defineGetter__("length", function() { return rf._len }) // This needs to be re-defined as a property sence length is a native prototype of the ecma Function constructor
    rf.message = message
    rf.__defineGetter__("is_set", function() { return true }) // prevent this from getting changed anywhere
    return rf

  },

  error_cb: function(f, proto_accept, message) {

    var tmp_proto_accept, tmp_f, tmp_message
    // This will swap the paramters passed in to the correct order so there is no need to remmeber it
    for ( var x in arguments )
      if ( typeof arguments[x] === "function" ) {
        tmp_f = arguments[x]
        for ( var n in arguments )
          if ( n === x )
            continue
          else if ( typeof arguments[n] === "string" || (arguments[n] && arguments[n].is_wizkit) )
            tmp_message = arguments[n]
          else if ( typeof arguments[n] === "object" )
            tmp_proto_accept = arguments[n]
        break
      }
    f = tmp_f
    proto_accept = tmp_proto_accept
    message = tmp_message

    if ( f && f.is_set ) {
      f.message = message || f.message
      return f
    }

    var output = this.args.settings.debug !== false && this.always() || this.pass() // Output needs to correspond to the debug state logger
    var rf = function() { // Return a wrapper for the passed into function (f) which gets called whether f is undefind or not

      output.line(clrs.red("<: Error "+output.PROGRAM_POINT)).line()
      var new_args = []
      for ( var o in arguments ) {  // Handle all of the arguments passed into the callback
        if ( !arguments[o] ) continue
        output.line().tab("Error message:").sp(arguments[o])
        if ( arguments[o] instanceof Error || arguments[o].is_wizkit )  // throw the parameter if it is on of the Error types
          new_args.push(arguments[o].toString())
        else
          new_args.push(arguments[o])
      }
      output.log()
      output.clear()
      if ( typeof f === "function" ) {
          f.pro = f.pro || {} // Better safe than sorry with multi-level object comparisons
          f.pro.message = rf.message && rf.message.toString() || ""
        f.apply(f.pro, new_args)
      }
    }

    rf.len = 0 // We make sure that the number or paramters this function accepts is the same as the passed in function
    if ( typeof f === "function" ) {
      rf.len = f.length // We make sure that the number or paramters this function accepts is the same as the passed in function
      if ( !f["never_switch_proto_flag"] ) { // Do not allow for prototype switching if this flag is set
        f.pro = (typeof proto_accept === "object" && proto_accept) || f.prototype
      }
      else if ( typeof proto_accept === "object" ) {
        f.pro = f.prototype
        var output = this.args.settings.debug !== false && this.always() || this.pass()
        output.line(clrs.red("<: Error "+output.PROGRAM_POINT)).line().tab(clrs.blue("Warning message:"))
        .sp("an attempt to switch the callback of a function with the [never_switch_proto_flag] property set was made.")
        .sp("This is not harmfull but might be unintended by the programer.").log()
      }
    }

      //    rf.__defineGetter__("length", function() { return rf._len }) // This needs to be re-defined as a property sence length is a native prototype of the ecma Function constructor
    rf.message = message
    rf.__defineGetter__("is_set", function() { return true }) // prevent this from getting changed anywhere
    return rf

  },

}


Wizkit.prototype.Logger.prototype = {

  get is_wizkit() {
    return this instanceof Wizkit.prototype.Logger // Just to check if the object is a Wizkit object
  },
  get toString() {
    var This = this
    return function() {
      return This.output
    }
  },
  get contains_data() {
    return this._contains_data
  },
  get color() {
    var This = this
    return function() {
      This.use_color = !!(arguments[0])
      return This
    }
  },
  get PROGRAM_POINT() {
    return new Error().stack.split("\n")[3].replace(/ */, "")

  },
  get pass() {
    var This = this
    return function() {
      return This
    }
  },
  get clear() {
    var This = this
    return function() {
      This.output = ""
      This._contains_data = false
      return This
    }
  },
  get sp() { // Alias for space
    this.last_command = arguments.callee.name
    var This = this
    return function() {
      var args = Array.prototype.slice.call(arguments)
      args.push(" ")
      return This._chain.apply(This, args)
    }
  },
  get space() {
    this.last_command = arguments.callee.name
    var This = this
    return function() {
      var args = Array.prototype.slice.call(arguments)
      args.push(" ")
      return This._chain.apply(This, args)
    }
  },
  get add_space() {
    this.last_command = arguments.callee.name
    var This = this
    return function() {
      var args = Array.prototype.slice.call(arguments)
      args.push(" ")
      return This._chain.apply(This, args)
    }
  },
  get add_tab() {
    this.last_command = arguments.callee.name
    var This = this
    return function() {
      var args = Array.prototype.slice.call(arguments)
      args.push("\t")
      return This._chain.apply(This, args)
    }
  },
  get tab() {
    this.last_command = arguments.callee.name
    var This = this
    return function() {
      var args = Array.prototype.slice.call(arguments)
      args.push("\t")
      return This._chain.apply(This, args)
    }
  },
  get add_line() { // Each segement of log_line will be on a seperate line
    this.last_command = arguments.callee.name
    var This = this
    return function() {
      var args = Array.prototype.slice.call(arguments)
      args.push("\n")
      return This._chain.apply(This, args)
    }
  },
  get line() { // Alias for add_line
    this.last_command = arguments.callee.name
    var This = this
    return function() {
      var args = Array.prototype.slice.call(arguments)
      args.push("\n")
      return This._chain.apply(This, args)
    }
  },
  // All other printing commands should call this
  get add() {
    this.last_command = arguments.callee.name
    var This = this
    return function() {
      var args = Array.prototype.slice.call(arguments)
      args.push("")
      return This._chain.apply(This, args)
    }

  },

  get _chain() {

    var This = this
    return function() {

      This._cache = []
      if ( !arguments.length )
        return This

      var args_len = arguments.length
      if ( !This.ignore_separater && args_len === 1 )
        this.output += arguments[0]

      for ( var i = 0; i < args_len-1; i++ ) {

        This.output += ( (!!(This.last_command) && !This.ignore_separater && arguments[args_len-1]) || "")+This.stringify_object(arguments[i], this.indentation_string)
        This.ignore_separater = false
        This._contains_data = true

      }
      return This
    }

  },

  get log() {

    var This = this

    return function() {

      if ( arguments.length > 0 ) {
        This[This.last_command] && This[This.last_command].apply(This, arguments) || This.add.apply(This, arguments) // Call the last command used before this log again.
      }
      colors = This.use_color && clrs || {blue: function(s){return s || ""}} // This makes more sence from a end-user stand point
      if ( This.output )
        console.log((This.log_title&&"["+colors.blue(This.log_title)+"] "||"")+This.output) // TODO: document.write and other printing methods?
      return this
    }

  },

  get log_false() {

    var This = this
    return function() {
      This.log.apply(This, arguments)
      return false
    }

  },

  get log_true() {

    var This = this
    return function() {
      This.log.apply(This, arguments)
      return true
    }

  },

  _log_option: function(option) { // Pretty much an internal function

    for ( var o in option )
      this[o] = option[o]
    return this

  },


  stringify_object: function(msg, indent_string, compound) { // compound will be placed at the start of each new object in the output (used internally)

    var Buffer = Buffer || function(){}
    var colors = this.use_color && clrs || fake_colors()

    indent_string = typeof indent_string === "string" && indent_string || "  "
    compound = compound || ""
    this.use_quotes = this.use_quotes || false

//    if ( msg === global )
//      return "" // passing in global causes reduntant parsing

    if ( msg && msg.is_wizkit ) {
      msg = this.stringify_object(msg.toString())
    }
    else if ( msg === null ) {
      msg = colors.cyan("null")
    }
    else if ( typeof msg == "boolean" ) { // NaN is the only js object which is not equal to itself
      msg = colors.red(msg.toString())
    }
    else if ( msg !== msg ) { // NaN is the only js object which is not equal to itself
      msg = colors.cyan("NaN")
    }
    else if ( msg instanceof Error ) { // NaN is the only js object which is not equal to itself
      var stack_string = msg.stack.split("\n")
      msg = colors.red(stack_string.splice(0,1)) + "\n" + colors.yellow(stack_string.join("\n"))
    }
    else if ( typeof msg === "undefined" ) {
      msg = colors.yellow("undefined")
    }
    else if ( msg instanceof Buffer ) {
      msg = colors.blue("Nodje Buffer() with length of: "+msg.length)//+Object.keys(msg).toString())
    }
    else if ( typeof msg === "object" || new Object().toString.call(msg) === "[object Function]" ) {
        var m = ""
        this.use_quotes = true // put quotes around strings if the request comes from here (is an Object)

        for ( var n = 0; n < this._cache.length; n++ )
          if ( this._cache[n] == msg ) // TODO: this needs to check the level and verify if it is circular
            return "" // Circular reference found, discard object processing

        var value_keys_length = Object.keys(msg).length // Used to determine loop index position

        if ( value_keys_length )
          this._cache.push(msg)

        if ( new Object().toString.call(msg) === "[object Function]" ) {
    //      compound+=indent_string
          // Extra space after comma at end of string is important for m.substr(0, m.length-2) below
          //m += "{ "+colors.blue("func(")+"\n"+colors.blue((msg.toString()+"\n").replace(/(.*)\n/g, compound+indent_string+"$1\n"))+compound+colors.blue(")")+", "
          m += colors.blue((msg.toString()+"\n").replace(/(.*)\n/g, compound+"$1\n"))+compound
          // Move the entire function text over to the current tab
        }
        else if ( msg.constructor === Array ) {
          m += "[ "
          if ( !value_keys_length )
            m += "], "
        }
        else {
          m += "{ "
          if ( !value_keys_length )
            m += "}, "
        }

        var cnt = 0, character_count = 0, str_add
        for ( var o in msg ) { // Loop through the Object values

          if ( cnt === 0 || typeof msg[o] === "object" ) // Is this the first loop
            m += "\n"+compound+indent_string

          if ( msg.constructor !== Array ) {
            str_add = this.stringify_object(o)+": "
            character_count += str_add.length
            m += str_add
          }
          // recursively call this function to parse the object. The indent_string is added to the begining to nest the output
          value = this.stringify_object(msg[o], indent_string, compound+indent_string) // Add the indent_string to the indent_string chain
          m += value+", "
          character_count += (value+", ").length

          if ( cnt === value_keys_length-1 ) { // Is this he last loop of the value

            m = m.substr(0, m.length-2)+"\n"+compound // Remove last space and comma at the end of the value loop

            if ( msg.constructor === Array )
              m += "], "
            else
              m += "}, "

          } else if ( character_count >= this.max_line_characters ) {
            m += "\n"+compound+indent_string
            character_count = 0
          }
          cnt++

        }

        m = m.substr(0, m.length-2) // Remove last space and comma at the end of the Object loop
        if ( compound && !this.compress_output )
          m = "\n"+compound+m

        msg = m
    }
    else if ( typeof msg === "number" ) {
      msg = colors.green(msg.toString().replace(/\./, colors.white("."))) // If there is a decimal, color it white
    }
    else if ( typeof msg === "string" ) {
      if ( this.use_quotes )
        msg = colors.blue("\"")+colors.magenta(msg)+colors.blue("\"")
      else
        msg = colors.magenta(msg)

    }
    else {
      msg = colors.red(msg.toString())
    }

    return msg

    },

}

if ( typeof module !== "undefined" && typeof module.exports !== "undefined" ) {
  module.exports = Wizkit
}
